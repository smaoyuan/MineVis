<?php

/**
 * ChainingLinkType
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    MineVis
 * @subpackage model
 * @author     Patrick Fiaux
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class ChainingLinkType extends BaseChainingLinkType {

    private $status_codes = array('Pending', 'Formatting Data', 'Runing Algorithm'
        , 'Parsing Results', 'Complete');
    private $microtime_start = null;

    /**
     * This is a helper function to get the runtime of functions,
     * It's designed to be called multiple time, each time it returns
     * the difference from the last time it was called.
     *
     * @staticvar string $microtime_start last call memory
     * @return float microtime interval
     */
    private function get_time_interval() {
        if ($this->microtime_start === null) {
            $this->microtime_start = microtime(true);
            return 0.0;
        }
        $now = microtime(true);
        $dif = $now - $this->microtime_start;
        $this->microtime_start = $now;

        return $dif;
    }

    /**
     * This returns a status description in words.
     * Right now jsut running or pending but it might be extended to
     * formating input, mining, parsing output saving results
     * @return String status description of job
     */
    public function getStatus() {
        return $this->status_codes[$this->getStatusCode()];
    }

    /**
     * Checks if the job started running yet.
     * @return Boolean true if started false otherwise
     */
    public function isStarted() {
        if ($this->getStartTime() != null) {
            return true;
        }
        return false;
    }

    /**
     * This checks the status of a chaining.
     * @return boolean true if job done, false otherwise
     */
    public function isDone() {
        return $this->getEndTime() != null;
    }

    /**
     * This returns the runtime of the mining job.
     * If it is complete it returns the final run time, if it is not complete
     * it returns the run time so far.
     * @return int runtime of mining job in seconds
     */
    public function getRunTime() {
        if ($this->isDone()) {
            $start = new DateTime($this->getStartTime());
            $end = new DateTime($this->getEndTime());
            //$runtime = $end - $start;
            $runtime = date_diff($start, $end)->format('%a days %h hours %i minutes %s seconds');
            return $runtime;
        } else if ($this->isStarted()) {
            $start = new DateTime($this->getStartTime());
            $end = new DateTime(date('c'));
            $runtime = date_diff($start, $end)->format('%a days %h hours %i minutes %s seconds');
            return $runtime;
        } else {
            return 0;
        }
    }

    /**
     * This function dumps the input needed to run the tree thingy.
     * @param type $forceOverwrite set to true to force overwriting cached files
     * even if they exist.
     */
    public function runAlgorithm($forceOverwrite = false) {
        $this->get_time_interval();
        $this->setStatusCode(1);
        $this->setStartTime(date('c'));
        $this->save();
        echo 'running from ' . getcwd() . "\n";
        echo 'generating output for ' . $this->name  . "\n";
        //Assuming we're running minetree...
        $mt = new MineTree($this);
        $mt->generateInput();
        echo('runtime: ' . $this->get_time_interval()   . "\n");
        $this->setStatusCode(2);
        $this->save();

        echo "running chaining...\n";
        $mt->run($this->getChaining()->getParams());
        echo('runtime: ' . $this->get_time_interval()   . "\n");
        $this->setStatusCode(3);
        $this->save();

        echo "parsing output...\n";
        $mt->parseOutput();
        echo('runtime: ' . $this->get_time_interval()   . "\n");
        $this->setStatusCode(4);
        $this->setEndTime(date('c'));
        $this->save();

        echo "done...\n";
    }
}
